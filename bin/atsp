#! /bin/sh

this_script=$(readlink -f "$0")
this_script_dir=$(dirname "${this_script}")

ATSP_ROOT=$(realpath "$this_script_dir/..")
export ATSP_ROOT

ATSP_CONF="$ATSP_ROOT"/conf
export ATSP_CONF
ATSP_DATA="$ATSP_ROOT"/data
export ATSP_DATA
ATSP_TASK="$ATSP_ROOT"/task
export ATSP_TASK
ATSP_UTIL="$ATSP_ROOT"/util
export ATSP_UTIL

# XXX: is it somehow better to make the list of things that come
#      in via conf explicit?

# turn on exporting things that are sourced
#set -a
set -o allexport
# shellcheck source=../conf
. "$ATSP_CONF"
# turn off exporting things that are sourced
#set +a
set +o allexport

########################################################################

# the parser project directory
ATSP_LANG_ROOT=$(realpath "$this_script_dir"/../..)
export ATSP_LANG_ROOT

########################################################################

# XXX: it may be that this file needs to protect against certain
#      variables not having values.  specifically, those that are in
#      the conf file?
#
#      e.g. if ATSP_LANG is not set, then hack-symlink will create an
#      incorrect symlink

########################################################################

# path to tree-sitter cli binary
#
# >= 0.19.4 added --no-bindings
# >= 0.20.3 added --abi
# <= 0.20.7 didn't have TREE_SITTER_LIBDIR support
#
# XXX: note that version string from binary may not be a good way to
#      compare versions because unreleased things appear to use the
#      same version string
ATSP_TS_PATH=${ATSP_TS_PATH:-tree-sitter}
export ATSP_TS_PATH

TREE_SITTER_DIR=${TREE_SITTER_DIR:-$ATSP_LANG_ROOT/.tree-sitter}
export TREE_SITTER_DIR

# XXX: the env var TREE_SITTER_LIBDIR only affects the tree-sitter cli
#      for versions beyond 0.20.7 -- we use it here for convenient
#      expression but just put its value in SO_INSTALL_DIR and use
#      that instead

# XXX: if computed, same as via the so-install-dir util script below
TREE_SITTER_LIBDIR=${TREE_SITTER_LIBDIR:-$TREE_SITTER_DIR/lib}
export TREE_SITTER_LIBDIR

# XXX: can we not just use TREE_SITTER_LIBDIR?
# where the shared object is looked for by tree-sitter cli
SO_INSTALL_DIR=$("$ATSP_UTIL"/so-install-dir "$TREE_SITTER_DIR")
export SO_INSTALL_DIR

# path to installed shared object
SO_INSTALL_PATH=$("$ATSP_UTIL"/so-install-path "$SO_INSTALL_DIR")
export SO_INSTALL_PATH

# build directory for shared object
#
# separating this from src has the following benefits:
#
# * easier to pick out what is src and what is produced
#   * can matter if wanting to remove files (e.g. cleaning)
#   * less to observe manually per set of items
# * multiple separate builds can be done without clobbering previous results
# * less clutter
#
# NOTE: making this the same as src will make some values in this program
#       incorrect so don't do that
#
# NOTE: a value that is a subdirectory of build is better than build because
#       build can also contain node or rust bindings.  don't want to
#       accidentally delete those

# XXX: could have a script that fetches a default value?
build_dir_name=${ATSP_BUILD_DIR_NAME:-build/atsp}
ATSP_BUILD_DIR=$ATSP_LANG_ROOT/$build_dir_name
export ATSP_BUILD_DIR

########################################################################

ATSP_SO_NAME=$("$ATSP_UTIL"/so-name)
export ATSP_SO_NAME

########################################################################

############
# generate #
############

ATSP_ABI=${ATSP_ABI:-$("$ATSP_UTIL"/atsp-abi)}
export ATSP_ABI

#########################################
# build-wasm and playground (sometimes) #
#########################################

# XXX: duplicated from task/.common

# XXX: start of duplication

verbose=${ATSP_VERBOSE:-0}

eprintf() {
  # shellcheck disable=SC2059
  printf "$@" 1>&2
}

deprintf() {
  if [ "1" = "$verbose" ]; then
    eprintf "$@"
  fi
}

# XXX: end of duplication

ATSP_PARSER_NAME=$("$ATSP_UTIL"/wasm-name)
export ATSP_PARSER_NAME

emsdk=${ATSP_EMSDK_DIR:-"$("$ATSP_UTIL"/atsp-emsdk-dir)"}

if [ "" = "$emsdk" ]; then
 eprintf "* Did not find an appropriate value for emsdk directory\n"
 exit 1
fi

if [ ! -d "$emsdk" ]; then
 eprintf "* emsdk value not a directory: %s\n" "$emsdk"
 exit 1
fi

emsdk=$(realpath "$emsdk")

deprintf "* emsdk: %s\n" "$emsdk"

# XXX: simpler just to source emsdk_env.sh?

# some consistency checking
#
# XXX: this should work as long as emsdk_env.* keeps setting the
#      EMSDK_NODE env var?
if [ ! -d "$emsdk/node" ]; then
  eprintf "* emsdk directory doesn't look right: %s\n" "$emsdk"
  exit 1
fi

emscripten="$emsdk/upstream/emscripten"

# XXX: validate node_version value somehow?
node_version=$(ls "$emsdk/node")

# store newline
newline='
'

# trying to detect if node_version is a single item or not based on
# whether it contains a newline
case "$node_version" in
  *"$newline"*)
    eprintf "* Found more than one item under: %s\n"
    eprintf "  %s\n" "$emsdk/node"
    eprintf "\n"
    eprintf "%s\n" "$node_version"
    exit 1
    ;;
  *)
    deprintf "* node version: %s\n" "$node_version"
    ;;
esac

node_bin_dir_path="$emsdk/node/$node_version/bin"
emsdk_node="$node_bin_dir_path/node"

export EMSDK="$emsdk"
export EMSDK_NODE="$emsdk_node"
# XXX: i think this causes emsdk's node to be used by tree-sitter...
export PATH="$emsdk:$emscripten:$node_bin_dir_path:$PATH"

########################################################################

task_script_path="$1"
task_script_name="$(basename "$task_script_path")"

task_script_full_path="$ATSP_TASK/$task_script_name"

shift

if [ ! -e "$task_script_full_path" ]; then
  printf "Subcommand not found: %s\n" "$task_script_name" 1>&2
  exit 1
fi

"$task_script_full_path" "$@"

